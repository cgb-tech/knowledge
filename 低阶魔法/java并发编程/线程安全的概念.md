# 什么是线程安全

`一个类`被`多个线程`以任意方式`同时`调用，且不需要外部额外同步和协同的情况下，仍然`保持内部数据正确`且`表现正确的行为`，那么这个类就是`线程安全`的

# 线程安全等级

`不可变`:

- final修饰的不可变类 String、Integer
  - final只是用来保证是不能直接被覆盖的
  - 当创建一个对象时，使用final关键字能够使得林那个一个线程不会访问处于"部分创建"的对象
- enum枚举类: why？： 加了final并且创建了多个final的对象

`线程安全`：线程安全类的任意方法操作都不会是该对象的数据处于不一致或者数据污染的情况

- java.util.concurrent下面的类,ConcurrentHashMap、LinkedBlockingQueue

`有条件的线程安全`：对于单独的访问类的方法，是线程安全，但是对于某些符合操作，需要外部类来同步

`线程兼容类`：使用synchronized控制同步访问每个代码块或类

如使用Collection.synchronizedList来包装一个List，使其变成线程安全

`线程对立类`: 是那些不管是否调用了外部同步都不能在并发使用时保证其安全的类

# 线程的同步异步、阻塞和非阻塞

同步：阻塞式调用，调用方必须等待响应方执行完毕才返回

异步：非阻塞试调用，立即返回，调用方无需等待相应方返回实际结果，响应方会通过状态、通知或回调来告知调用方

![1580738415574](C:\Users\888\AppData\Roaming\Typora\typora-user-images\1580738415574.png)

阻塞：调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回

非阻塞：非阻塞调用指在不能立即得到结果之前，该调用不会阻塞当前线程，而会立即返回

- 同步异步关注点是得到结果的`方式`
- 阻塞和非阻塞关注点在等待调用结果返回时的`状态`

# 线程状态及java中线程常见方法

Thread中的六种状态

```java
 public enum State {
        
        NEW,
    
        RUNNABLE,

        BLOCKED, //阻塞态

        TIMED_WAITING, //加了时间的等待

        TERMINATED; //终结状态
    }
```

NEW：线程创建但是还没有调用start()方法
RUNNABLE ：可运行线程的状态，线程已经在JVM虚拟机中执行，但是可能需要等待操作系统资源，如处理器。RUNNABLE包括RUNNING和READY
BLOCKED ：阻塞的线程意味着正在等待监视器锁，来进入或重入synchronized代码块或者方法
WAITING ：等待状态，需要其他线程中断或通知来唤醒
TIMED_WAITING ：定时等待状态，在指定等待时间后返回，或提前被其他线程中断或通知返回
TERMINATED ：终止线程的线程状态，线程已执行完成

![1580785595520](C:\Users\888\AppData\Roaming\Typora\typora-user-images\1580785595520.png)

Thread.yield()
线程让步，使用了这个方法，当前线程就会退出CPU时间片，让其他线程或当前线程使用CPU时间篇执行

Thread.sleep()
线程休眠，主动让出当前CPU时间，在指定时间过后，CPU会返回继续执行该线程。sleep方法不会释放当前所持有的锁

Thread.join()
等待该线程死亡/终止，当前线程会等待调用该方法的线程执行完毕后才能继续执行

Object.wait()
Object类的方法，调用前必须拥有对象锁，例如在synchronized代码块内，调用wait方法后，对象锁会释放，线程进入WAITING等待状态

# 线程的并发与并行

- 并发

  - 定义:逻辑上的同时处理。能处理多个事件，但是并不一定是同时进行的。
  - 说明:这里可能只有一个处理器的多个线程，由系统的调度，让不同的线程在不同的小的时间段内执行各自的线程任务逻辑。

- 并行

  - 定义：物理或是实际的同时处理。能在同一时刻处理多个事件。
  - 说明：并行具有并发的含义，并发不一定是并行的，因为不是同时进行。


# 死锁

死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程

`原因`:两个及以上的线程，抢占2把及以上的锁，抢占锁的顺序不一致

`避免和处理死锁问题`:

- 不使用锁，不使用2把及以上的锁
- 必须使用2把及以上锁的时候，确保在整个应用程序中对获取锁的顺序是一致的
- 尝试获取具有超时释放的锁，例如Lock中的tryLock来获取锁
- 当发生了Java-level的锁时，重启程序来干掉进程/线程

## `jps`

列举正在运行的虚拟机进程并显示虚拟机执行的主类以及这些进程的唯一ID（PID）

## `jstack`

用于JVM当前时刻的线程快照，得到JVM当前每一条线程正在执行的堆栈信息，定位线程长时间卡顿问题，如死锁、死循环等问题

  

  

  

  

  































